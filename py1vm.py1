# System Functions
@v 表 'print'
@v 整 'int'
@v 寸 'len'
@v 字 'str'
@v 追 'append'
@v 抜 'pop'
@v 裂 'split'
@v 数 'isnumeric'
@v 換 'chr'
@v 開 'open'
@v 読 'read'
@v 逝 'exit'
@v 削 'strip'
@v 行 'splitlines'

# Modules
@v 系 'sys'

# Control Flow
@v 術 'def'
@v も 'if'
@v 他 'else'
@v 循 'while'
@v 返 'return'
@v 入 'in'

# Keys & Opcodes
@v 筒 '"stack"'
@v 憶 '"mem"'
@v 指 '"ip"'
@v 令 '"code"'
@v 票 '"labels"'

@v 積 '"PUSH"'
@v 足 '"ADD"'
@v 引 '"SUB"'
@v 掛 '"MUL"'
@v 割 '"DIV"'
@v 剰 '"MOD"'
@v 印 '"PRINT"'
@v 蔵 '"STORE"'
@v 荷 '"LOAD"'
@v 札 '"LABEL"'
@v 飛 '"JUMP"'
@v 無 '"JZERO"'
@v 負 '"LT"'
@v 同 '"EQ"'
@v 喚 '"CALL"'
@v 束 '"MKLIST"'
@v 得 '"GET"'
@v 包 '"CONTAINS"'

# Built-in function names for CALL
@v 長 '"len"'
@v 文 '"chr"'
@v 加 '"append"'

# Data & Separator
@v 空 '" "'
@v モ '"r"'
@v 権 '"utf-8"'

# Variables
@v 態 'state'
@v 順 'idx'
@v コ 'codes'
@v 線 'line'
@v 部 'parts'
@v 技 'op'
@v 具 'arg'
@v 山 'stack'
@v 値 'val'
@v 甲 'val_a'
@v 乙 'val_b'
@v メ 'mem'
@v 辞 'labels'
@v 鍵 'key'
@v 動 'step'
@v 調 'scan'
@v 走 'run'
@v 引 'argv'
@v 径 'path'
@v 本 'body'
@v 生 'raw_lines'

$

# --- Label Scan Function ---
術 調(コ):
 辞 = {}
 順 = 0
 循 順 < 寸(コ):
  線 = コ[順]
  部 = 線.裂(空)
  も 寸(部) > 0:
   技 = 部[0]
   も 技 == 札:
    具 = 部[1]
    辞[具] = 順
  順 = 順 + 1
 返 辞

# --- 1-Step Execution Function ---
術 動(態):
 順 = 態[指]
 コ = 態[令]
 辞 = 態[票]
 も 順 < 寸(コ):
  線 = コ[順]
  部 = 線.裂(空)
  も 寸(部) > 0:
   技 = 部[0]
   山 = 態[筒]
   メ = 態[憶]
   
   # PUSH
   も 技 == 積:
    具 = 部[1]
    も 具.数():
     山.追(整(具))
    他:
     山.追(具)
   他:
    # ADD
    も 技 == 足:
     乙 = 山.抜()
     甲 = 山.抜()
     山.追(甲 + 乙)
    他:
     # SUB
     も 技 == 引:
      乙 = 山.抜()
      甲 = 山.抜()
      山.追(甲 - 乙)
     他:
      # MOD
      も 技 == 剰:
       乙 = 山.抜()
       甲 = 山.抜()
       山.追(甲 % 乙)
      他:
       # PRINT
       も 技 == 印:
        値 = 山.抜()
        表(値)
       他:
        # STORE
        も 技 == 蔵:
         具 = 部[1]
         値 = 山.抜()
         メ[具] = 値
        他:
         # LOAD
         も 技 == 荷:
          具 = 部[1]
          山.追(メ[具])
         他:
          # LT
          も 技 == 負:
           乙 = 山.抜()
           甲 = 山.抜()
           も 甲 < 乙:
            山.追(1)
           他:
            山.追(0)
          他:
           # EQ
           も 技 == 同:
            乙 = 山.抜()
            甲 = 山.抜()
            も 甲 == 乙:
             山.追(1)
            他:
             山.追(0)
           他:
            # JZERO
            も 技 == 無:
             具 = 部[1]
             値 = 山.抜()
             も 値 == 0:
              態[指] = 辞[具]
              返 0
            他:
             # JUMP
             も 技 == 飛:
              具 = 部[1]
              態[指] = 辞[具]
              返 0
             他:
              # LABEL (No op)
              も 技 == 札:
               0
              他:
               # MKLIST
               も 技 == 束:
                山.追([])
               他:
                # GET
                も 技 == 得:
                 乙 = 山.抜()
                 甲 = 山.抜()
                 山.追(甲[乙])
                他:
                 # CONTAINS
                 も 技 == 包:
                  乙 = 山.抜()
                  甲 = 山.抜()
                  も 甲 入 乙:
                   山.追(1)
                  他:
                   山.追(0)
                 他:
                  # CALL
                  も 技 == 喚:
                   具 = 部[1]
                   も 具 == 長:
                    値 = 山.抜()
                    山.追(寸(値))
                   他:
                    も 具 == 文:
                     値 = 山.抜()
                     山.追(換(値))
                    他:
                     も 具 == 加:
                      乙 = 山.抜()
                      甲 = 山.抜()
                      甲.追(乙)
  態[指] = 順 + 1

# --- Loop Driver ---
術 走(コ):
 辞 = 調(コ)
 態 = {}
 態[筒] = []
 態[憶] = {}
 態[指] = 0
 態[令] = コ
 態[票] = 辞
 循 態[指] < 寸(コ):
  動(態)

# --- Main Entry Point ---
# Check argv
引 = 系.argv
も 寸(引) < 2:
 系.逝(1)

# Read File
径 = 引[1]
本 = 開(径, モ, encoding=権).読()

# Parse Lines
生 = 本.行()
コ = []
順 = 0
循 順 < 寸(生):
 線 = 生[順]
 線 = 線.削()
 も 寸(線) > 0:
  コ.追(線)
 順 = 順 + 1

# Run
走(コ)
