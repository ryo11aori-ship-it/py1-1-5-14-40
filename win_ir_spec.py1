# Windows Native IR Generator for FizzBuzz
# This mimics x64 Assembly + Windows API logic

# System
@v 表 'print'
@v 追 'append'
@v 字 'str'
@v 結合 '"\n".join'

# Opcodes (Windows Native IR)
@v 置 '"MOV"'
@v 確 '"ALLOC"'
@v 書 '"WRITE_MEM"'

# Control
@v 飛 '"JMP"'
@v 零 '"JZ"'
@v 非 '"JNZ"'
@v 比 '"CMP"'
@v 加 '"ADD"'

# OS API
@v 連 '"LOAD_DLL"'
@v 得 '"GET_PROC"'
@v 呼 '"CALL_API"'
@v 押 '"PUSH"'

# Registers
@v 壱 '"R1"'
@v 弐 '"R2"'
@v 参 '"R3"'
@v 肆 '"R4"'

# Data
@v 幕 '"--- Generating Windows Native IR ---"'
@v コ 'codes'

# Values
@v 蔵 '"kernel32.dll"'
@v 出 '"GetStdHandle"'
@v 書込 '"WriteFile"'
@v 終 '"ExitProcess"'
@v 負1 '"-11"'

$

コ = []

# --- Header: Setup OS API ---
# Handle = GetStdHandle(-11)
コ.追("LOAD_DLL kernel32.dll")
コ.追("GET_PROC GetStdHandle")
コ.追("MOV RCX -11")
コ.追("CALL_API GetStdHandle")
コ.追("MOV R4 RAX")

# Prepare WriteFile address
コ.追("GET_PROC WriteFile")
# Prepare ExitProcess address
コ.追("GET_PROC ExitProcess")

# --- Logic: FizzBuzz Loop (1 to 16) ---
コ.追("MOV R1 1")

# LABEL LOOP_START
コ.追("LABEL LOOP_START")

# CMP R1, 16
コ.追("MOV R2 16")
コ.追("CMP R1 R2")
# JZ EXIT
コ.追("JZ EXIT")

# FizzBuzz Logic Mock (Output "1")
コ.追("WRITE_MEM 100 49") # '1'
コ.追("WRITE_MEM 101 10") # '\n'

# Arg1: RCX = Handle (R4)
コ.追("MOV RCX R4")
# Arg2: RDX = Buffer Address (100)
コ.追("MOV RDX 100")
# Arg3: R8 = Length (2)
コ.追("MOV R8 2")
# Arg4: R9 = WrittenBytesPtr (200)
コ.追("MOV R9 200")
# Arg5: Stack param (0)
コ.追("PUSH 0") 
コ.追("CALL_API WriteFile")

# Increment R1
コ.追("ADD R1 1")

# LABEL EXIT
コ.追("LABEL EXIT")
コ.追("MOV RCX 0")
コ.追("CALL_API ExitProcess")

表(結合(コ))
