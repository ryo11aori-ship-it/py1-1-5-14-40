# System Functions (Renamed to Kanji to avoid Reserved Chars collision)
@v 表 'print'
@v 整 'int'
@v 寸 'len'
@v 字 'str'
@v 追 'append'
@v 抜 'pop'
@v 裂 'split'
@v 数 'isnumeric'

# Control Flow
@v 術 'def'
@v も 'if'
@v 他 'else'

# Keys
@v 筒 '"stack"'
@v 憶 '"mem"'
@v 指 '"ip"'
@v 令 '"code"'
@v 札 '"labels"'

# Opcodes
@v 積 '"PUSH"'
@v 足 '"ADD"'
@v 引 '"SUB"'
@v 掛 '"MUL"'
@v 印 '"PRINT"'
@v 蔵 '"STORE"'
@v 荷 '"LOAD"'

# Separator & Data
@v 空 '" "'
@v 壱 '"PUSH 10"'
@v 弐 '"PUSH 20"'
@v 参 '"ADD"'
@v 肆 '"PRINT"'
@v 幕 '"--- Step ---"'

# Variables (Keys are Kanji, Values are safe Python var names)
@v 態 'state'
@v 順 'idx'
@v 文 'codes'
@v 行 'line'
@v 部 'parts'
@v 技 'op'
@v 具 'arg'
@v 山 'stack'
@v 値 'val'
@v 甲 'val_a'
@v 乙 'val_b'
@v メ 'mem'

$

# --- 1-Step Execution Function ---
# s: State Dict
術 動(態):
 順 = 態[指]
 文 = 態[令]
 
 も 順 < 寸(文):
  行 = 文[順]
  部 = 行.裂(空)
  技 = 部[0]
  
  山 = 態[筒]
  メ = 態[憶]
  
  # PUSH val
  も 技 == 積:
   具 = 部[1]
   も 具.数():
    山.追(整(具))
   他:
    山.追(具)
  
  # ADD
  他:
   も 技 == 足:
    乙 = 山.抜()
    甲 = 山.抜()
    山.追(甲 + 乙)
  
  # PRINT
  他:
   も 技 == 印:
    値 = 山.抜()
    表(値)

  # Update IP
  態[指] = 順 + 1

# --- Manual Test Driver ---
# Construct Code List
文 = []
文.追(壱)
文.追(弐)
文.追(参)
文.追(肆)

# Init State
態 = {}
態[筒] = []
態[憶] = {}
態[指] = 0
態[令] = 文

# Run 4 steps
表(幕)
動(態)
表(態[筒])

表(幕)
動(態)
表(態[筒])

表(幕)
動(態)
表(態[筒])

表(幕)
動(態)
表(態[筒])
