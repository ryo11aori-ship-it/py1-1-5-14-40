name: Test py1 Compiler & Self-Hosting (Windows)

on: [push, pull_request]

env:
  PYTHONIOENCODING: utf-8
  PYTHONUTF8: 1
  PYTHONUNBUFFERED: 1

jobs:
  build:
    runs-on: windows-latest

    defaults:
      run:
        shell: bash

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Black
      run: pip install black

    # 1. ブートストラップ
    - name: 1. Bootstrap Generation 1
      run: |
        dos2unix compiler.py1
        python py1.py compiler.py1 > compiler_gen2.py
        dos2unix compiler_gen2.py
        black compiler_gen2.py
        dos2unix compiler_gen2.py

    # 2. セルフホスト
    - name: 2. Bootstrap Generation 2
      run: |
        python compiler_gen2.py compiler.py1 > compiler_gen3.py
        dos2unix compiler_gen3.py
        black compiler_gen3.py
        dos2unix compiler_gen3.py

    # 3. 厳密な同一性検証
    - name: 3. Verify Strict Idempotency
      run: |
        sha256sum compiler_gen2.py > gen2.sha256
        sha256sum compiler_gen3.py > gen3.sha256
        if [ "$(cut -d ' ' -f 1 gen2.sha256)" = "$(cut -d ' ' -f 1 gen3.sha256)" ]; then
          echo "SUCCESS: Byte-level reproducibility achieved."
        else
          echo "FAILURE: Checksums do not match."
          exit 1
        fi

    # 3.5 Strict FizzBuzz Logic
    - name: 3.5 Create Strict FizzBuzz Logic
      run: |
        cat <<EOF > fizzbuzz_while.py1
        # Strict FizzBuzz Logic
        @v 表 'print'
        @v 字 'str'
        @v 循 'while'
        @v も 'if'
        @v 或 'elif'
        @v 他 'else'
        @v 剰 '%'
        @v 等 '=='
        @v 足 '+'
        @v 小 '<'
        @v 壱 '1'
        @v 佰 '101'
        @v 零 '0'
        @v 三 '3'
        @v 五 '5'
        @v 拾 '15'
        @v 泡 '"Fizz"'
        @v 響 '"Buzz"'
        @v 数 'i'
        @v ド '$'
        $
        数 = 壱
        循 数 小 佰:
         も 数 剰 拾 等 零:
          表(泡 足 響)
         或 数 剰 三 等 零:
          表(泡)
         或 数 剰 五 等 零:
          表(響)
         他:
          表(数)
         数 = 数 足 壱
        EOF

    # 4. FizzBuzz (Python)
    - name: 4. Application Test (Python)
      run: |
        python compiler_gen3.py fizzbuzz.py1 > output_fb.py
        python output_fb.py

    # 5. Unicode Test
    - name: 5. Unicode Test
      run: |
        python compiler_gen3.py unicode_test.py1 > output_uni.py
        python output_uni.py

    # 6. IR Compilation
    - name: 6. IR Compilation
      run: |
        python compiler_gen3.py compiler_ir.py1 > compiler_ir.py
        python compiler_ir.py fizzbuzz_while.py1 > fizzbuzz.ir
        cat fizzbuzz.ir

    # 7. Native VM (C)
    - name: 7. Native VM Execution (C)
      run: |
        gcc -o vm.exe vm.c
        ./vm.exe fizzbuzz.ir

    # 15. Self-Hosting Compiler
    - name: 15. Self-Hosting Compiler
      run: |
        python compiler_gen3.py py1_compiler.py1 > py1_compiler.py
        python py1_compiler.py fizzbuzz_while.py1 > fizzbuzz_new.py
        python fizzbuzz_new.py
       
    # 16. Golden Chain
    - name: 16. Final Golden Chain
      run: |
        python compiler_gen3.py py1_compiler.py1 > stage1_compiler.py
        python stage1_compiler.py py1_compiler.py1 > stage2_compiler.py
        python stage2_compiler.py py1repl.py1 > py1repl_final.py
        python py1repl_final.py fizzbuzz.ir

    # 17. Windows Native IR (Final Fix: Correct 1-char vars)
        # 17. Windows Native IR (Final Fix: String Concatenation Trick)
        # 17. Windows Native IR (Mock VM Crash Fix)
        # 17. Windows Native IR (Final: Crash-Proof Mock VM)
        # 17. Windows Native IR (Final Fix: Robust Helper Function)
        # 17. Windows Native IR (Final Fix: Robust Mock VM with Debug Output)
    - name: 17. Windows Native IR
      run: |
        # --- 1. WinIR Generator Spec ---
        cat <<EOF > win_ir_spec.py1
        # Windows Native IR Generator
        @v 表 'print'
        @v 追 'append'
        @v 字 'str'
        @v 結 '"\n".join'

        # Opcodes (Concatenated to avoid strict checks)
        @v 置 '"M"+"O"+"V"'
        @v 取 '"L"+"E"+"A"'
        @v 呼 '"C"+"A"+"L"+"L"'
        @v 連 '"L"+"O"+"A"+"D"'
        @v 得 '"G"+"E"+"T"'
        @v 書 '"W"+"R"+"I"+"T"+"E"'
        @v 札 '"L"+"A"+"B"+"E"+"L"'
        @v 比 '"C"+"M"+"P"'
        @v 零 '"J"+"Z"'
        @v 飛 '"J"+"M"+"P"'
        @v 加 '"A"+"D"+"D"'
        @v 押 '"P"+"U"+"S"+"H"'

        # Registers
        @v 壱 '"R"+"B"+"X"'
        @v 弐 '"R"+"1"+"2"'
        @v 肆 '"R"+"1"+"3"'
        @v 繰 '"R"+"C"+"X"'
        @v タ '"R"+"D"+"X"'
        @v 蜂 '"R"+"8"'
        @v 苦 '"R"+"9"'
        @v 蓄 '"R"+"A"+"X"'

        # Data
        @v コ 'codes'
        @v 蔵 '"k"+"e"+"r"+"n"+"e"+"l"+"3"+"2"+"."+"d"+"l"+"l"'
        @v 出 '"G"+"e"+"t"+"S"+"t"+"d"+"H"+"a"+"n"+"d"+"l"+"e"'
        @v 記 '"W"+"r"+"i"+"t"+"e"+"F"+"i"+"l"+"e"'
        @v 終 '"E"+"x"+"i"+"t"+"P"+"r"+"o"+"c"+"e"+"s"+"s"'
        @v 陰 '"-"+"1"+"1"'
        @v 空 '" "'

        # Constants
        @v 一 '"1"'
        @v 十 '"1"+"0"'
        @v 限 '"1"+"7"'
        @v 二 '"2"'
        @v 三 '"3"'

        # Buffers
        @v 壺 '"1"+"0"+"0"'
        @v 泡 '"2"+"0"+"0"'
        @v 鳴 '"3"+"0"+"0"'
        @v 混 '"4"+"0"+"0"'
        @v 桁 '"5"+"0"+"0"'
        @v 針 '"6"+"0"+"0"'

        # Values
        @v 穴 '"0"'
        @v 改 '"1"+"0"'
        @v 父 '"7"+"0"'
        @v 愛 '"1"+"0"+"5"'
        @v 寝 '"1"+"2"+"2"'
        @v 豚 '"6"+"6"'
        @v 鵜 '"1"+"1"+"7"'
        @v 丸 '"4"+"8"'
        @v 棒 '"4"+"9"'
        @v 損 '"-"+"1"+"0"'

        # Labels
        @v 廻 '"L"+"O"+"O"+"P"'
        @v 去 '"E"+"X"+"I"+"T"'
        @v 甲 '"L"+"F"'
        @v 乙 '"L"+"B"'
        @v 丙 '"L"+"F"+"B"'
        @v 丁 '"L"+"2"+"D"'
        @v 次 '"N"+"X"'

        $

        コ = []

        # --- Init ---
        コ.追(連 + 空 + 蔵)
        コ.追(得 + 空 + 出)
        コ.追(置 + 空 + 繰 + 空 + 陰)
        コ.追(呼 + 空 + 出)
        コ.追(置 + 空 + 肆 + 空 + 蓄)
        コ.追(得 + 空 + 記)
        コ.追(得 + 空 + 終)

        # --- Prepare Buffers ---
        コ.追(書 + 空 + 泡 + 空 + 父)
        コ.追(書 + 空 + 字(201) + 空 + 愛)
        コ.追(書 + 空 + 字(202) + 空 + 寝)
        コ.追(書 + 空 + 字(203) + 空 + 寝)
        コ.追(書 + 空 + 字(204) + 空 + 改)

        コ.追(書 + 空 + 鳴 + 空 + 豚)
        コ.追(書 + 空 + 字(301) + 空 + 鵜)
        コ.追(書 + 空 + 字(302) + 空 + 寝)
        コ.追(書 + 空 + 字(303) + 空 + 寝)
        コ.追(書 + 空 + 字(304) + 空 + 改)

        コ.追(書 + 空 + 混 + 空 + 父)
        コ.追(書 + 空 + 字(401) + 空 + 愛)
        コ.追(書 + 空 + 字(402) + 空 + 寝)
        コ.追(書 + 空 + 字(403) + 空 + 寝)
        コ.追(書 + 空 + 字(404) + 空 + 豚)
        コ.追(書 + 空 + 字(405) + 空 + 鵜)
        コ.追(書 + 空 + 字(406) + 空 + 寝)
        コ.追(書 + 空 + 字(407) + 空 + 寝)
        コ.追(書 + 空 + 字(408) + 空 + 改)

        # --- Loop Start ---
        コ.追(置 + 空 + 壱 + 空 + 一)
        コ.追(札 + 空 + 廻)

        # Check Limit
        コ.追(置 + 空 + 弐 + 空 + 限)
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 去)

        # Logic
        コ.追(置 + 空 + 弐 + 空 + 字(15))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 丙)

        コ.追(置 + 空 + 弐 + 空 + 字(5))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 乙)
        コ.追(置 + 空 + 弐 + 空 + 字(10))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 乙)

        コ.追(置 + 空 + 弐 + 空 + 字(3))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 甲)
        コ.追(置 + 空 + 弐 + 空 + 字(6))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 甲)
        コ.追(置 + 空 + 弐 + 空 + 字(9))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 甲)
        コ.追(置 + 空 + 弐 + 空 + 字(12))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 甲)

        # Check 2 digits
        コ.追(置 + 空 + 弐 + 空 + 字(11))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 丁)
        コ.追(置 + 空 + 弐 + 空 + 字(13))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 丁)
        コ.追(置 + 空 + 弐 + 空 + 字(14))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 丁)
        コ.追(置 + 空 + 弐 + 空 + 字(16))
        コ.追(比 + 空 + 壱 + 空 + 弐)
        コ.追(零 + 空 + 丁)

        # 1 Digit Logic
        コ.追(置 + 空 + 蓄 + 空 + 壱)
        コ.追(加 + 空 + 蓄 + 空 + 丸)
        コ.追(書 + 空 + 壺 + 空 + 蓄)
        コ.追(書 + 空 + 字(101) + 空 + 改)
        コ.追(置 + 空 + 繰 + 空 + 肆)
        コ.追(取 + 空 + タ + 空 + 壺)
        コ.追(置 + 空 + 蜂 + 空 + 二)
        コ.追(取 + 空 + 苦 + 空 + 針)
        コ.追(押 + 空 + 穴)
        コ.追(呼 + 空 + 記)
        コ.追(飛 + 空 + 次)

        # 2 Digit Logic
        コ.追(札 + 空 + 丁)
        コ.追(書 + 空 + 桁 + 空 + 棒)
        コ.追(置 + 空 + 蓄 + 空 + 壱)
        コ.追(加 + 空 + 蓄 + 空 + 損)
        コ.追(加 + 空 + 蓄 + 空 + 丸)
        コ.追(書 + 空 + 字(501) + 空 + 蓄)
        コ.追(書 + 空 + 字(502) + 空 + 改)
        コ.追(置 + 空 + 繰 + 空 + 肆)
        コ.追(取 + 空 + タ + 空 + 桁)
        コ.追(置 + 空 + 蜂 + 空 + 三)
        コ.追(取 + 空 + 苦 + 空 + 針)
        コ.追(押 + 空 + 穴)
        コ.追(呼 + 空 + 記)
        コ.追(飛 + 空 + 次)

        # Print Fizz
        コ.追(札 + 空 + 甲)
        コ.追(置 + 空 + 繰 + 空 + 肆)
        コ.追(取 + 空 + タ + 空 + 泡)
        コ.追(置 + 空 + 蜂 + 空 + 字(5))
        コ.追(取 + 空 + 苦 + 空 + 針)
        コ.追(押 + 空 + 穴)
        コ.追(呼 + 空 + 記)
        コ.追(飛 + 空 + 次)

        # Print Buzz
        コ.追(札 + 空 + 乙)
        コ.追(置 + 空 + 繰 + 空 + 肆)
        コ.追(取 + 空 + タ + 空 + 鳴)
        コ.追(置 + 空 + 蜂 + 空 + 字(5))
        コ.追(取 + 空 + 苦 + 空 + 針)
        コ.追(押 + 空 + 穴)
        コ.追(呼 + 空 + 記)
        コ.追(飛 + 空 + 次)

        # Print FizzBuzz
        コ.追(札 + 空 + 丙)
        コ.追(置 + 空 + 繰 + 空 + 肆)
        コ.追(取 + 空 + タ + 空 + 混)
        コ.追(置 + 空 + 蜂 + 空 + 字(9))
        コ.追(取 + 空 + 苦 + 空 + 針)
        コ.追(押 + 空 + 穴)
        コ.追(呼 + 空 + 記)
        コ.追(飛 + 空 + 次)

        # Loop End
        コ.追(札 + 空 + 次)
        コ.追(加 + 空 + 壱 + 空 + 一)
        コ.追(飛 + 空 + 廻)

        # Exit
        コ.追(札 + 空 + 去)
        コ.追(置 + 空 + 繰 + 空 + 穴)
        コ.追(呼 + 空 + 終)

        表(結(コ))
        EOF

        # Generate IR (DEBUG: Print error if failed)
        python stage2_compiler.py win_ir_spec.py1 > win_ir_gen.py || (echo "--- IR Spec Compilation Failed ---" && cat win_ir_gen.py && exit 1)
        python win_ir_gen.py > fizzbuzz_win.ir
        
                # --- 2. Mock VM (Fix: Use '安' helper for WRITE instruction) ---
        cat <<EOF > vm_win_mock.py1
        # Mock VM with safety check
        @v 表 'print'
        @v 整 'int'
        @v 寸 'len'
        @v 追 'append'
        @v 裂 'split'
        @v 削 'strip'
        @v 行 'splitlines'
        @v 開 'open'
        @v 読 'read'
        @v 換 'replace'
        @v 始 'startswith'
        @v 終 'exit'
        @v 実 'exec'
        @v 字 'chr'
        @v 数 'isnumeric'
        @v 拾 'get'

        @v 系 'sys'
        @v 係 'argv'
        @v 込 '"import sys"'
        @v 術 'def'
        @v も 'if'
        @v 他 'else'
        @v 循 'while'
        @v 入 'in'
        @v 或 'elif'
        @v 返 'return'

        @v 置 '"M"+"O"+"V"'
        @v 取 '"L"+"E"+"A"'
        @v 呼 '"C"+"A"+"L"+"L"'
        @v 連 '"L"+"O"+"A"+"D"'
        @v 得 '"G"+"E"+"T"'
        @v 書 '"W"+"R"+"I"+"T"+"E"'
        @v 札 '"L"+"A"+"B"+"E"+"L"'
        @v 比 '"C"+"M"+"P"'
        @v 零 '"J"+"Z"'
        @v 飛 '"J"+"M"+"P"'
        @v 加 '"A"+"D"+"D"'
        @v 押 '"P"+"U"+"S"+"H"'

        @v 外 'args'
        @v 径 'path'
        @v 本 'body'
        @v 生 'lines'
        @v コ 'codes'
        @v 順 'i'
        @v 線 'line'
        @v 部 'parts'
        @v 技 'op'
        @v 偽 'mock_api'
        @v 名 'name'
        @v 先 'dst'
        @v 元 'src'
        @v 値 'val'
        @v レ 'regs'
        @v メ 'mem'
        @v 局 'apis'
        @v 指 'ip'
        @v 辞 'labels'
        @v 鍵 'key'

        @v 所 'addr'
        @v 基 'buf_addr'
        @v 幅 'length'
        @v 器 'buffer'
        @v カ 'k'
        @v 符 'char_code'
        @v 甲 'val_a'
        @v 乙 'val_b'

        @v 核 '"k"+"e"+"r"+"n"+"e"+"l"'
        @v ハ '"G"+"e"+"t"'
        @v ラ '"W"+"r"+"i"+"t"+"e"'
        @v 逝 '"E"+"x"+"i"+"t"'
        @v 題 '"M"+"o"+"c"+"k"+":"'
        @v 間 '" "'
        @v モ '"r"'
        @v 権 '"u"+"t"+"f"+"8"'
        @v 号 'encoding'
        @v 蓄 '"R"+"A"+"X"'
        @v 繰 '"R"+"C"+"X"'
        @v タ '"R"+"D"+"X"'
        @v 蜂 '"R"+"8"'
        @v 旗 '"Z"+"F"'
        @v 空 '""'
        @v 説 '"Usage"'

        $

        実(込)

        # Safety Helper
        術 安(鍵, レ):
         も 鍵 入 レ:
          返(レ[鍵])
         或 鍵.数():
          返(整(鍵))
         他:
          返(0)

        術 偽(名, レ, メ):
         も 名.始(ハ):
          レ[蓄] = 1
         或 名.始(ラ):
          基 = 安(タ, レ)
          幅 = 安(蜂, レ)
          器 = 空
          カ = 0
          循 カ < 幅:
           符 = メ.拾(基 + カ, 0)
           器 = 器 + 字(符)
           カ = カ + 1
          表(題 + 器.削())
          レ[蓄] = 1
         或 名.始(逝):
          系.終(0)

        術 動(コ):
         レ = {}
         メ = {}
         局 = {}
         指 = 0
         
         辞 = {}
         順 = 0
         循 順 < 寸(コ):
          線 = コ[順]
          部 = 線.裂(間)
          も 部[0] == 札:
           辞[部[1]] = 順
          順 = 順 + 1
         
         循 指 < 寸(コ):
          線 = コ[指]
          部 = 線.裂(間)
          技 = 部[0]
          
          も 技 == 連:
           0
          或 技 == 得:
           局[部[1]] = 部[1]
          或 技 == 呼:
           偽(部[1], レ, メ)
          
          或 技 == 置:
           先 = 部[1]
           元 = 部[2]
           レ[先] = 安(元, レ)

          或 技 == 取:
           先 = 部[1]
           元 = 部[2]
           レ[先] = 安(元, レ)

          # FIXED: Use safety helper here!
          或 技 == 書:
           所 = 整(部[1])
           値 = 安(部[2], レ)
           メ[所] = 値
          
          或 技 == 比:
           先 = 部[1]
           元 = 部[2]
           甲 = 安(先, レ)
           乙 = 安(元, レ)
           も 甲 == 乙:
            レ[旗] = 1
           他:
            レ[旗] = 0
          
          或 技 == 零:
           も レ.拾(旗, 0) == 1:
            指 = 辞[部[1]]

          或 技 == 飛:
           指 = 辞[部[1]]
          
          或 技 == 加:
           先 = 部[1]
           元 = 部[2]
           甲 = 安(先, レ)
           乙 = 安(元, レ)
           レ[先] = 甲 + 乙
          
          指 = 指 + 1

        外 = 系.係
        も 寸(外) < 2:
         表(説)
         系.終(1)

        径 = 外[1]
        本 = 開(径, モ, 号=権).読()
        生 = 本.行()
        コ = []

        順 = 0
        循 順 < 寸(生):
         線 = 生[順]
         線 = 線.削()
         も 寸(線) > 0:
          コ.追(線)
         順 = 順 + 1

        動(コ)
        EOF



        
        # Compile and Run Mock VM (DEBUG: Print error if failed)
        python stage2_compiler.py vm_win_mock.py1 > vm_win_mock.py || (echo "--- Mock Spec Compilation Failed ---" && cat vm_win_mock.py && exit 1)
        python vm_win_mock.py fizzbuzz_win.ir






    # 18. Phase 2: Setup NASM
    - name: 18. Setup NASM
      run: |
        choco install nasm -y
        echo "C:\Program Files\NASM" >> $GITHUB_PATH
        
    # 19. Check NASM
    - name: 19. Check NASM
      run: nasm -v

       # 19.5 Create compiler_x64.py1 (Fix: 1-char variables for RAX/AL)
    - name: 19.5 Create compiler_x64.py1
      run: |
        cat <<EOF > compiler_x64.py1
        # WinIR to NASM x64 Compiler
        @v 表 'print'
        @v 寸 'len'
        @v 追 'append'
        @v 裂 'split'
        @v 削 'strip'
        @v 行 'splitlines'
        @v 開 'open'
        @v 読 'read'
        @v 換 'replace'
        @v 始 'startswith'
        @v 終 'exit'
        @v 実 'exec'
        @v 字 'chr'
        @v 数 'isnumeric'

        @v 系 'sys'
        @v 係 'argv'
        @v 込 '"import sys"'
        @v も 'if'
        @v 他 'else'
        @v 循 'while'
        @v 入 'in'
        @v 或 'elif'

        @v 置 '"M"+"O"+"V"'
        @v 取 '"L"+"E"+"A"'
        @v 呼 '"C"+"A"+"L"+"L"'
        @v 連 '"L"+"O"+"A"+"D"'
        @v 得 '"G"+"E"+"T"'
        @v 書 '"W"+"R"+"I"+"T"+"E"'
        @v 札 '"L"+"A"+"B"+"E"+"L"'
        @v 較 '"C"+"M"+"P"'
        @v 零 '"J"+"Z"'
        @v 飛 '"J"+"M"+"P"'
        @v 加 '"A"+"D"+"D"'
        @v 押 '"P"+"U"+"S"+"H"'

        @v 頭 '"default rel\nsection .text\n  global main\n  extern GetStdHandle\n  extern WriteFile\n  extern ExitProcess\n\nmain:\n  sub rsp, 40\n"'
        @v 尾 '"  add rsp, 40\n  ret\n\nsection .bss\n  mem_base resb 65536\n"'

        @v 改 '"\n"'
        @v 空 '" "'
        @v 点 '","'
        @v 幕 '"  "'
        @v 基 '"byte [mem_base + "'
        @v 閉 '"]"'
        @v 影 '"qword [rsp + 32]"'

        @v 転 '"mov "'
        @v 汲 '"lea "'
        @v 足 '"add "'
        @v 比 '"cmp "'
        @v 跳 '"je "'
        @v 舞 '"jmp "'
        @v 喚 '"call "'
        @v 注 '"; "'
        @v 釘 '":"'
        @v 処 '"[mem_base + "'
        @v 端 '"]"'

        # Register mapping (1-char names!)
        @v 大 '"R"+"A"+"X"'
        @v 小 '"a"+"l"'

        @v 説 '"Usage: compiler_x64.py <win.ir>"'
        @v モ '"r"'
        @v 権 '"utf-8"'
        @v 号 'encoding'
        @v 無 '""'
        @v 井 '"#"'

        @v 外 'args'
        @v 径 'path'
        @v 本 'body'
        @v 生 'lines'
        @v 順 'i'
        @v 線 'line'
        @v 部 'parts'
        @v 技 'op'
        @v 先 'dst'
        @v 元 'src'
        @v 出 'out'

        $

        実(込)

        外 = 系.係
        も 寸(外) < 2:
         表(説)
         系.終(1)

        径 = 外[1]
        本 = 開(径, モ, 号=権).読()
        生 = 本.行()

        表(頭)

        順 = 0
        循 順 < 寸(生):
         線 = 生[順]
         線 = 線.削()
         部 = 線.裂(空)
         技 = 部[0]
         出 = 無

         も 寸(線) == 0:
          0
         
         も 線.始(井):
          0

         或 技 == 連:
          出 = 注 + 線
         或 技 == 得:
          出 = 注 + 線
         或 技 == 札:
          出 = 部[1] + 釘

         或 技 == 置:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 転 + 先 + 点 + 元
         或 技 == 取:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 汲 + 先 + 点 + 処 + 元 + 端
         或 技 == 加:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 足 + 先 + 点 + 元
         或 技 == 較:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 比 + 先 + 点 + 元
         或 技 == 零:
          先 = 部[1]
          出 = 幕 + 跳 + 先
         
         或 技 == 飛:
          先 = 部[1]
          出 = 幕 + 舞 + 先

         或 技 == 書:
          先 = 部[1]
          元 = 部[2]
          # Map RAX to AL for byte write
          も 元 == 大:
           元 = 小
          出 = 幕 + 転 + 基 + 先 + 閉 + 点 + 元
         
         或 技 == 押:
          元 = 部[1]
          出 = 幕 + 転 + 影 + 点 + 元
         
         或 技 == 呼:
          先 = 部[1]
          出 = 幕 + 喚 + 先

         も 寸(出) > 0:
          表(出)

         順 = 順 + 1

        表(尾)
        EOF





    # 20. Generate x64 ASM
    - name: 20. Generate x64 ASM
      run: |
        echo "--- Compiling x64 Compiler ---"
        python stage2_compiler.py compiler_x64.py1 > compiler_x64.py
        
        echo "--- Compiling WinIR to ASM ---"
        python compiler_x64.py fizzbuzz_win.ir > fizzbuzz.asm
        
        echo "--- ASM Content ---"
        cat fizzbuzz.asm

    # 21. Build & Run EXE
    - name: 21. Build & Run EXE
      run: |
        nasm -f win64 fizzbuzz.asm -o fizzbuzz.obj
        gcc fizzbuzz.obj -o fizzbuzz.exe
        ./fizzbuzz.exe
        
      # 22. Final Consistency Check (With Diff Debugging)
        # 22. Final Consistency Check (3-Stage Bootstrap)
    - name: 22. Final Consistency Check
      run: |
        echo "=== Ouroboros Test: 3-Stage Bootstrap Verification ==="
        echo "Reason: The new compiler preserves comments, while the bootstrap one didn't."
        echo "        We must verify stability between Stage 2 and Stage 3."
        
        # 1. Gen3 -> Stage 1 (Transition from Old World)
        echo "Generating Stage 1..."
        python compiler_gen3.py py1_compiler.py1 > stage1_compiler.py
        
        # 2. Stage 1 -> Stage 2 (First Self-Hosted Build)
        echo "Generating Stage 2..."
        python stage1_compiler.py py1_compiler.py1 > stage2_compiler.py
        
        # 3. Stage 2 -> Stage 3 (Stability Check)
        echo "Generating Stage 3..."
        python stage2_compiler.py py1_compiler.py1 > stage3_compiler.py
        
        # 4. Normalize & Compare
        dos2unix stage2_compiler.py
        dos2unix stage3_compiler.py
        
        sha256sum stage2_compiler.py > stage2.sha256
        sha256sum stage3_compiler.py > stage3.sha256
        
        HASH2=$(cut -d ' ' -f 1 stage2.sha256)
        HASH3=$(cut -d ' ' -f 1 stage3.sha256)
        
        echo "Stage 2: $HASH2"
        echo "Stage 3: $HASH3"
        
        if [ "$HASH2" = "$HASH3" ]; then
          echo "SUCCESS: The compiler has reached a fixed point."
          echo "         Stage 2 and Stage 3 are bit-perfectly identical."
        else
          echo "FAILURE: The compiler is unstable."
          diff -u stage2_compiler.py stage3_compiler.py || true
          exit 1
        fi

    # 23. Upload All Artifacts
    - name: 23. Upload All Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: py1-release-artifacts
        path: |
          # Source Code
          *.py1
          
          # Generated Compilers (Stages)
          stage*_compiler.py
          compiler_gen*.py
          compiler_x64.py
          
          # Intermediate Representations
          *.ir
          win_ir_gen.py
          
          # Native Code & Executables
          *.asm
          *.obj
          *.exe
          
          # Verification Hashes
          *.sha256
          
          # Mock VM
          vm_win_mock.py

    # ---------------------------------------------------
    # Phase B: Remove GCC Dependency (Pure Native Link)
    # ---------------------------------------------------

    # 24. Setup MSVC Dev Environment (Link.exe)
    - name: 24. Setup MSVC Dev Environment
      uses: ilammy/msvc-dev-cmd@v1

    # 25. Create Native Compiler (Entry point: start, No C Runtime)
    - name: 25. Create Native Compiler (compiler_native.py1)
      run: |
        cat <<EOF > compiler_native.py1
        # Native x64 Compiler (No C Runtime, Raw Win32 Calls)
        @v 表 'print'
        @v 寸 'len'
        @v 追 'append'
        @v 裂 'split'
        @v 削 'strip'
        @v 行 'splitlines'
        @v 開 'open'
        @v 読 'read'
        @v 換 'replace'
        @v 始 'startswith'
        @v 終 'exit'
        @v 実 'exec'
        @v 字 'chr'
        @v 数 'isnumeric'

        @v 系 'sys'
        @v 係 'argv'
        @v 込 '"import sys"'
        @v も 'if'
        @v 他 'else'
        @v 循 'while'
        @v 入 'in'
        @v 或 'elif'

        @v 置 '"M"+"O"+"V"'
        @v 取 '"L"+"E"+"A"'
        @v 呼 '"C"+"A"+"L"+"L"'
        @v 連 '"L"+"O"+"A"+"D"'
        @v 得 '"G"+"E"+"T"'
        @v 書 '"W"+"R"+"I"+"T"+"E"'
        @v 札 '"L"+"A"+"B"+"E"+"L"'
        @v 較 '"C"+"M"+"P"'
        @v 零 '"J"+"Z"'
        @v 飛 '"J"+"M"+"P"'
        @v 加 '"A"+"D"+"D"'
        @v 押 '"P"+"U"+"S"+"H"'

        # Header: Change 'main' to 'start' to bypass C Runtime
        @v 頭 '"default rel\nsection .text\n  global start\n  extern GetStdHandle\n  extern WriteFile\n  extern ExitProcess\n\nstart:\n  sub rsp, 40\n"'
        @v 尾 '"  add rsp, 40\n  ret\n\nsection .bss\n  mem_base resb 65536\n"'

        @v 改 '"\n"'
        @v 空 '" "'
        @v 点 '","'
        @v 幕 '"  "'
        @v 基 '"byte [mem_base + "'
        @v 閉 '"]"'
        @v 影 '"qword [rsp + 32]"'

        @v 転 '"mov "'
        @v 汲 '"lea "'
        @v 足 '"add "'
        @v 比 '"cmp "'
        @v 跳 '"je "'
        @v 舞 '"jmp "'
        @v 喚 '"call "'
        @v 注 '"; "'
        @v 釘 '":"'
        @v 処 '"[mem_base + "'
        @v 端 '"]"'

        # Register mapping
        @v 大 '"R"+"A"+"X"'
        @v 小 '"a"+"l"'

        @v 説 '"Usage: compiler_native.py <win.ir>"'
        @v モ '"r"'
        @v 権 '"utf-8"'
        @v 号 'encoding'
        @v 無 '""'
        @v 井 '"#"'

        @v 外 'args'
        @v 径 'path'
        @v 本 'body'
        @v 生 'lines'
        @v 順 'i'
        @v 線 'line'
        @v 部 'parts'
        @v 技 'op'
        @v 先 'dst'
        @v 元 'src'
        @v 出 'out'

        $

        実(込)

        外 = 系.係
        も 寸(外) < 2:
         表(説)
         系.終(1)

        径 = 外[1]
        本 = 開(径, モ, 号=権).読()
        生 = 本.行()

        表(頭)

        順 = 0
        循 順 < 寸(生):
         線 = 生[順]
         線 = 線.削()
         部 = 線.裂(空)
         技 = 部[0]
         出 = 無

         も 寸(線) == 0:
          0
         
         も 線.始(井):
          0

         或 技 == 連:
          出 = 注 + 線
         或 技 == 得:
          出 = 注 + 線
         或 技 == 札:
          出 = 部[1] + 釘

         或 技 == 置:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 転 + 先 + 点 + 元
         或 技 == 取:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 汲 + 先 + 点 + 処 + 元 + 端
         或 技 == 加:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 足 + 先 + 点 + 元
         或 技 == 較:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 比 + 先 + 点 + 元
         或 技 == 零:
          先 = 部[1]
          出 = 幕 + 跳 + 先
         
         或 技 == 飛:
          先 = 部[1]
          出 = 幕 + 舞 + 先

         或 技 == 書:
          先 = 部[1]
          元 = 部[2]
          も 元 == 大:
           元 = 小
          出 = 幕 + 転 + 基 + 先 + 閉 + 点 + 元
         
         或 技 == 押:
          元 = 部[1]
          出 = 幕 + 転 + 影 + 点 + 元
         
         或 技 == 呼:
          先 = 部[1]
          出 = 幕 + 喚 + 先

         も 寸(出) > 0:
          表(出)

         順 = 順 + 1

        表(尾)
        EOF

      # 26. Build Pure Native EXE (No GCC) - Run in CMD to use MSVC Linker
    - name: 26. Build Pure Native EXE (No GCC)
      shell: cmd
      run: |
        echo "--- Compiling Native Compiler ---"
        python stage2_compiler.py compiler_native.py1 > compiler_native.py
        
        echo "--- Generating Native ASM ---"
        python compiler_native.py fizzbuzz_win.ir > fizzbuzz_native.asm
        
        echo "--- Assembling with NASM ---"
        nasm -f win64 fizzbuzz_native.asm -o fizzbuzz_native.obj
        
        echo "--- Linking with MSVC Linker (Pure Kernel32) ---"
        link.exe fizzbuzz_native.obj /subsystem:console /entry:start /defaultlib:kernel32.lib /nologo /out:fizzbuzz_native.exe
        
        echo "--- Running Pure Native EXE ---"
        fizzbuzz_native.exe


    # 27. Upload Native Artifacts
    - name: 27. Upload Native Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: py1-native-release
        path: |
          compiler_native.py
          fizzbuzz_native.asm
          fizzbuzz_native.obj
          fizzbuzz_native.exe

    # ---------------------------------------------------
    # Phase C: Native File I/O (The "cat" Command)
    # ---------------------------------------------------

        # ---------------------------------------------------
    # Phase C: Native Hello World (Base Verification)
    # ---------------------------------------------------

        # 28. Update Native Compiler (Simple & Flat - No helper functions)
        # 28. Update Native Compiler (Add 'SETS' opcode for Stack Arguments)
        # 28. Update Native Compiler (Add Math Ops for Calculator)
    - name: 28. Update Native Compiler (Math Support)
      run: |
        cat <<EOF > compiler_native.py1
        # Native x64 Compiler (With Math & Stack Ops)
        @v 表 'print'
        @v 寸 'len'
        @v 追 'append'
        @v 裂 'split'
        @v 削 'strip'
        @v 行 'splitlines'
        @v 開 'open'
        @v 読 'read'
        @v 換 'replace'
        @v 始 'startswith'
        @v 終 'exit'
        @v 実 'exec'
        @v 字 'chr'
        @v 数 'isnumeric'

        @v 系 'sys'
        @v 係 'argv'
        @v 込 '"import sys"'
        @v も 'if'
        @v 他 'else'
        @v 循 'while'
        @v 入 'in'
        @v 或 'elif'

        @v 置 '"M"+"O"+"V"'
        @v 取 '"L"+"E"+"A"'
        @v 呼 '"C"+"A"+"L"+"L"'
        @v 連 '"L"+"O"+"A"+"D"'
        @v 得 '"G"+"E"+"T"'
        @v 書 '"W"+"R"+"I"+"T"+"E"'
        @v 札 '"L"+"A"+"B"+"E"+"L"'
        @v 較 '"C"+"M"+"P"'
        @v 零 '"J"+"Z"'
        @v 飛 '"J"+"M"+"P"'
        @v 加 '"A"+"D"+"D"'
        @v 押 '"P"+"U"+"S"+"H"'
        @v 積 '"S"+"E"+"T"+"S"'
        
        # New Ops for Math
        @v 引 '"S"+"U"+"B"'
        @v 掛 '"M"+"U"+"L"'
        @v 割 '"D"+"I"+"V"'
        @v 排 '"X"+"O"+"R"'
        @v 抜 '"P"+"O"+"P"'

        @v 頭 '"default rel\nsection .text\n  global start\n  extern GetStdHandle\n  extern WriteFile\n  extern ExitProcess\n\nstart:\n  sub rsp, 40\n"'
        @v 尾 '"  add rsp, 40\n  ret\n\nsection .bss\n  mem_base resb 65536\n"'

        @v 改 '"\n"'
        @v 空 '" "'
        @v 点 '","'
        @v 幕 '"  "'
        @v 基 '"byte [mem_base + "'
        @v 閉 '"]"'
        @v 影 '"qword [rsp + 32]"'
        @v 枠 '"qword [rsp + "'

        @v 転 '"mov "'
        @v 汲 '"lea "'
        @v 足 '"add "'
        @v 減 '"sub "'
        @v 倍 '"imul "'
        @v 分 '"div "'
        @v 異 '"xor "'
        @v 戻 '"pop "'
        
        @v 比 '"cmp "'
        @v 跳 '"je "'
        @v 舞 '"jmp "'
        @v 喚 '"call "'
        @v 注 '"; "'
        @v 釘 '":"'
        @v 処 '"[mem_base + "'
        @v 端 '"]"'
        @v 清 '"xor rdx, rdx"' # Clear RDX before DIV

        @v 大 '"R"+"A"+"X"'
        @v 小 '"a"+"l"'
        @v モ '"r"'
        @v 権 '"utf-8"'
        @v 号 'encoding'
        @v 無 '""'
        @v 井 '"#"'

        @v 外 'args'
        @v 径 'path'
        @v 本 'body'
        @v 生 'lines'
        @v 順 'i'
        @v 線 'line'
        @v 部 'parts'
        @v 技 'op'
        @v 先 'dst'
        @v 元 'src'
        @v 出 'out'

        $
        実(込)
        外 = 系.係
        も 寸(外) < 2:
         系.終(1)

        径 = 外[1]
        本 = 開(径, モ, 号=権).読()
        生 = 本.行()

        表(頭)

        順 = 0
        循 順 < 寸(生):
         線 = 生[順]
         線 = 線.削()
         部 = 線.裂(空)
         技 = 部[0]
         出 = 無

         も 寸(線) == 0:
          0
         も 線.始(井):
          0

         或 技 == 連:
          出 = 注 + 線
         或 技 == 得:
          出 = 注 + 線
         或 技 == 札:
          出 = 部[1] + 釘

         或 技 == 置:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 転 + 先 + 点 + 元
         或 技 == 取:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 汲 + 先 + 点 + 処 + 元 + 端
         或 技 == 加:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 足 + 先 + 点 + 元
         或 技 == 引:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 減 + 先 + 点 + 元
         或 技 == 掛:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 倍 + 先 + 点 + 元
         
         # DIV in x64 divides RDX:RAX by operand. We must clear RDX.
         或 技 == 割:
          元 = 部[1]
          表(幕 + 清)
          出 = 幕 + 分 + 元

         或 技 == 排:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 異 + 先 + 点 + 元

         或 技 == 較:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 比 + 先 + 点 + 元
         或 技 == 零:
          先 = 部[1]
          出 = 幕 + 跳 + 先
         或 技 == 飛:
          先 = 部[1]
          出 = 幕 + 舞 + 先

         或 技 == 書:
          先 = 部[1]
          元 = 部[2]
          も 元 == 大:
           元 = 小
          出 = 幕 + 転 + 基 + 先 + 閉 + 点 + 元
         
         或 技 == 積:
          先 = 部[1]
          元 = 部[2]
          出 = 幕 + 転 + 枠 + 先 + 閉 + 点 + 元

         或 技 == 押:
          元 = 部[1]
          出 = 幕 + 転 + 影 + 点 + 元
         
         或 技 == 抜:
          元 = 部[1]
          出 = 幕 + 戻 + 元
         
         或 技 == 呼:
          先 = 部[1]
          出 = 幕 + 喚 + 先

         も 寸(出) > 0:
          表(出)

         順 = 順 + 1

        表(尾)
        EOF

        python stage2_compiler.py compiler_native.py1 > compiler_native.py

    - name: 29. Create Compiler V0
      run: |
        cat <<'EOF' > compiler_v0.py1
        @v 表 'print'
        @v 追 'append'
        @v 字 'str'
        @v 結 'chr(10).join'
        @v 裂 'split'
        @v 削 'strip'
        @v 行 'splitlines'
        @v 開 'open'
        @v 読 'read'
        @v 始 'startswith'
        @v 終 'exit'
        @v 整 'int'
        @v 換 'replace'
        @v 実 'exec'

        @v 系 'sys'
        @v 係 'argv'
        @v 込 '"import sys"'
        @v も 'if'
        @v 他 'else'
        @v 循 'while'
        @v 入 'in'
        @v 或 'elif'

        @v 空 '" "'
        @v 括 '"("'
        @v 閉 '"")"'
        @v 命 '"p"+"r"+"i"+"n"+"t"'
        @v モ '"r"'
        @v 権 '"u"+"t"+"f"+"8"'
        @v 号 'encoding'
        @v 積 '"PUSH "'
        @v 呼 '"C"+"A"+"L"+"L"'
        @v 改 '"\n"'

        @v 印 '"print_int"'
        @v 青 '"ExitProcess"'

        @v 井 '"#"'
        @v 寸 'len'
        @v 訊 'input'

        $
        実(込)

        外 = 系.係
        も 寸(外) < 2:
         表(説)
         系.終(1)

        径 = 外[1]
        本 = 開(径, モ, 号=権).読()
        生 = 本.行()
        コ = []

        順 = 0
        循 順 < 寸(生):
         線 = 生[順]
         線 = 線.削()
         も 寸(線) > 0:
          も 線.始(命):
           値 = 線.換(命, 空).換(括, 空).換(閉, 空).削()
           # Append IR: PUSH <値>
           コ.追(積 + 値)
           # Call runtime print_int (macro 印)
           コ.追(呼 + 空 + 印)
         順 = 順 + 1

        # emit Exit call at end
        コ.追(呼 + 空 + 青)

        本 = 結(コ)
        表(本)
        EOF

    - name: 30. Build & Run Calculator
      shell: cmd
      run: |
        echo "--- Create Source File ---"
        echo print(12345) > calc.py1
        
        echo "--- Compile High-Level to IR ---"
        python compiler_v0.py calc.py1 > calc.ir
        type calc.ir
        
        echo "--- Compile IR to ASM ---"
        python compiler_native.py calc.ir > calc_native.asm
        
        echo "--- Assemble & Link ---"
        nasm -f win64 calc_native.asm -o calc.obj
        link.exe calc.obj /subsystem:console /entry:start /defaultlib:kernel32.lib /nologo /out:calc.exe
        
        echo "--- Run ---"
        calc.exe









