name: Test py1 Compiler & Self-Hosting (Windows)

on: [push, pull_request]

env:
  PYTHONIOENCODING: utf-8
  PYTHONUTF8: 1
  PYTHONUNBUFFERED: 1

jobs:
  build:
    runs-on: windows-latest

    defaults:
      run:
        shell: bash

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Black
      run: pip install black

    # 1. ブートストラップ
    - name: 1. Bootstrap Generation 1
      run: |
        echo "--- Normalizing Source to LF ---"
        dos2unix compiler.py1
        
        echo "--- Compiling Gen 1 ---"
        python py1.py compiler.py1 > compiler_gen2.py
        
        echo "--- Normalizing Output to LF ---"
        dos2unix compiler_gen2.py
        black compiler_gen2.py
        dos2unix compiler_gen2.py

    # 2. セルフホスト
    - name: 2. Bootstrap Generation 2
      run: |
        echo "--- Compiling Gen 2 ---"
        python compiler_gen2.py compiler.py1 > compiler_gen3.py
        
        echo "--- Normalizing Output to LF ---"
        dos2unix compiler_gen3.py
        black compiler_gen3.py
        dos2unix compiler_gen3.py

    # 3. 厳密な同一性検証
    - name: 3. Verify Strict Idempotency (SHA256)
      run: |
        echo "--- Calculating SHA256 Checksums ---"
        sha256sum compiler_gen2.py > gen2.sha256
        sha256sum compiler_gen3.py > gen3.sha256
        
        HASH2=$(cut -d ' ' -f 1 gen2.sha256)
        HASH3=$(cut -d ' ' -f 1 gen3.sha256)
        
        if [ "$HASH2" = "$HASH3" ]; then
          echo "SUCCESS: Byte-level reproducibility achieved."
        else
          echo "FAILURE: Checksums do not match."
          exit 1
        fi

    # 【重要】ここで厳格版ソースコードを生成して上書きする
    - name: 3.5 Create Strict FizzBuzz Logic
      run: |
        cat <<EOF > fizzbuzz_while.py1
        # Strict FizzBuzz Logic
        # No raw strings, no keywords in body.

        # Keywords & Functions
        @v 表 'print'
        @v 字 'str'
        @v 循 'while'
        @v も 'if'
        @v 或 'elif'
        @v 他 'else'
        @v 剰 '%'
        @v 等 '=='
        @v 足 '+'
        @v 小 '<'

        # Values & Literals
        @v 壱 '1'
        @v 佰 '101'
        @v 零 '0'
        @v 三 '3'
        @v 五 '5'
        @v 拾 '15'
        @v 泡 '"Fizz"'
        @v 響 '"Buzz"'
        @v 数 'i'
        @v ド '$'

        $

        数 = 壱

        # while i < 101:
        循 数 小 佰:
         
         # if i % 15 == 0:
         も 数 剰 拾 等 零:
          表(泡 足 響)
         
         # elif i % 3 == 0:
         或 数 剰 三 等 零:
          表(泡)
         
         # elif i % 5 == 0:
         或 数 剰 五 等 零:
          表(響)
         
         # else:
         他:
          表(数)
         
         # i = i + 1
         数 = 数 足 壱
        EOF

    # 4. FizzBuzz (Python Transpilation)
    - name: 4. Application Test (FizzBuzz - Python)
      run: |
        python compiler_gen3.py fizzbuzz.py1 > output_fb.py
        python output_fb.py

    # 5. Unicodeテスト
    - name: 5. Unicode Test
      run: |
        python compiler_gen3.py unicode_test.py1 > output_uni.py
        python output_uni.py

    # 6. IRコンパイラのコンパイルと実行
    - name: 6. IR Compilation (FizzBuzz IR)
      run: |
        python compiler_gen3.py compiler_ir.py1 > compiler_ir.py
        python compiler_ir.py fizzbuzz_while.py1 > fizzbuzz.ir
        cat fizzbuzz.ir

    # 7. ネイティブVM (C言語)
    - name: 7. Native VM Execution (C Implementation)
      run: |
        gcc -o vm.exe vm.c
        ./vm.exe fizzbuzz.ir

    # 8. 機能テスト
    - name: 8. Feature Test
      run: |
        python compiler_ir.py feature_test.py1 > features.ir
        ./vm.exe features.ir

    # 9. Lexer Test
    - name: 9. Minimal Lexer Test
      run: |
        python compiler_ir.py lexer.py1 > lexer.ir
        ./vm.exe lexer.ir || true

    # 10. Phase 2 VM Prototype
    - name: 10. Phase 2 VM Prototype
      run: |
        python compiler_gen3.py vm_step.py1 > vm_step.py
        python vm_step.py
        
    # 11. Phase 2.5: VM Jump Test
    - name: 11. VM Jump Test
      run: |
        python compiler_gen3.py vm_jump.py1 > vm_jump.py
        python vm_jump.py

    # 12. Phase 2.5: VM Full
    - name: 12. VM Full FizzBuzz
      run: |
        python compiler_gen3.py vm_full.py1 > vm_full.py
        python vm_full.py
    
    # 13. Phase 3: Final py1 VM execution
    - name: 13. Phase 3 py1VM
      run: |
        python compiler_ir.py fizzbuzz_while.py1 > fizzbuzz.ir
        python compiler_gen3.py py1vm.py1 > py1vm.py
        python py1vm.py fizzbuzz.ir

    # 14. Phase 4: REPL Build
    - name: 14. Phase 4 REPL Build
      run: |
        python compiler_gen3.py py1repl.py1 > py1repl.py
        python py1repl.py fizzbuzz.ir

    # 15. Self-Hosting Compiler (ここでStrictチェックが走るため、Step 3.5が必須)
    - name: 15. Self-Hosting Compiler
      run: |
        echo "--- Bootstrap: Compiling py1_compiler.py1 using old compiler ---"
        python compiler_gen3.py py1_compiler.py1 > py1_compiler.py
        
        echo "--- Self-Host: Compiling FizzBuzz using NEW compiler ---"
        python py1_compiler.py fizzbuzz_while.py1 > fizzbuzz_new.py
        
        echo "--- Running New FizzBuzz ---"
        python fizzbuzz_new.py
       
    # 16. Phase 6: The Golden Chain
    - name: 16. Final Golden Chain
      run: |
        python compiler_gen3.py py1_compiler.py1 > stage1_compiler.py
        python stage1_compiler.py py1_compiler.py1 > stage2_compiler.py
        python stage2_compiler.py py1repl.py1 > py1repl_final.py
        python py1repl_final.py fizzbuzz.ir

    # 17. Windows Native IR
    - name: 17. Windows Native IR
      run: |
        python stage2_compiler.py win_ir_spec.py1 > win_ir_gen.py
        python win_ir_gen.py > fizzbuzz_win.ir
        cat fizzbuzz_win.ir
        python stage2_compiler.py vm_win_mock.py1 > vm_win_mock.py
        python vm_win_mock.py fizzbuzz_win.ir

    # 18. Phase 2: Setup NASM
    - name: 18. Setup NASM
      run: |
        choco install nasm -y
        echo "C:\Program Files\NASM" >> $GITHUB_PATH
        
    # 19. Check NASM
    - name: 19. Check NASM
      run: nasm -v
        # 【追加】最新の厳格な compiler_x64.py1 を作成する
    
    - name: 19.5 Create compiler_x64.py1
      run: |
        cat <<'EOF' > compiler_x64.py1
        # WinIR to NASM x64 Compiler
        # Strict 1-char variable naming applied.

        # System
        @v 表 'print'
        @v 寸 'len'
        @v 追 'append'
        @v 裂 'split'
        @v 削 'strip'
        @v 行 'splitlines'
        @v 開 'open'
        @v 読 'read'
        @v 換 'replace'
        @v 始 'startswith'
        @v 終 'exit'
        @v 実 'exec'
        @v 字 'chr'
        @v 数 'isnumeric'

        # Modules
        @v 系 'sys'
        @v 係 'argv'
        @v 込 '"import sys"'

        # Control Flow
        @v も 'if'
        @v 他 'else'
        @v 循 'while'
        @v 入 'in'
        @v 或 'elif'

        # Opcodes (WinIR)
        @v 置 '"MOV"'
        @v 呼 '"CALL_API"'
        @v 連 '"LOAD_DLL"'
        @v 得 '"GET_PROC"'
        @v 書 '"WRITE_MEM"'
        @v 札 '"LABEL"'
        @v 較 '"CMP"'
        @v 零 '"JZ"'
        @v 加 '"ADD"'
        @v 押 '"PUSH"'

        # Assembly Templates
        @v 頭 '"default rel\nsection .text\n  global main\n  extern GetStdHandle\n  extern WriteFile\n  extern ExitProcess\n\nmain:\n  sub rsp, 40\n"'
        @v 尾 '"  add rsp, 40\n  ret\n\nsection .bss\n  mem_base resb 65536\n"'

        # Formatting Constants & Output Strings
        @v 改 '"\n"'
        @v 空 '" "'
        @v 点 '","'
        @v 幕 '"  "'
        @v 基 '"byte [mem_base + "'
        @v 閉 '"]"'
        @v 影 '"qword [rsp + 32]"'

        # Assembly Instructions as 1-char Macros
        @v 転 '"mov "'
        @v 足 '"add "'
        @v 比 '"cmp "'
        @v 跳 '"je "'
        @v 喚 '"call "'
        @v 注 '"; "'
        @v 釘 '":"'

        # Misc Literals
        @v 説 '"Usage: compiler_x64.py <win.ir>"'
        @v モ '"r"'
        @v 権 '"utf-8"'
        @v 号 'encoding'
        @v 無 '""'
        @v 井 '"#"'

        # Variables
        @v 外 'args'
        @v 径 'path'
        @v 本 'body'
        @v 生 'lines'
        @v 順 'i'
        @v 線 'line'
        @v 部 'parts'
        @v 技 'op'
        @v 先 'dst'
        @v 元 'src'
        @v 出 'out'

        $

        実(込)

        # Main Logic
        外 = 系.係
        も 寸(外) < 2:
         表(説)
         系.終(1)

        径 = 外[1]
        本 = 開(径, モ, 号=権).読()
        生 = 本.行()

        # Output Header
        表(頭)

        順 = 0
        循 順 < 寸(生):
         線 = 生[順]
         線 = 線.削()
         部 = 線.裂(空)
         技 = 部[0]
         出 = 無

         # Skip empty lines
         も 寸(線) == 0:
          0
         
         # Skip comment lines
         も 線.始(井):
          0

         # LOAD_DLL / GET_PROC -> Comment out
         或 技 == 連:
          出 = 注 + 線
         或 技 == 得:
          出 = 注 + 線

         # LABEL name -> name:
         或 技 == 札:
          出 = 部[1] + 釘

         # MOV dst, src
         或 技 == 置:
          先 = 部[1]
          元 = 部[2]
          # mov dst, src
          出 = 幕 + 転 + 先 + 点 + 元

         # ADD dst, src
         或 技 == 加:
          先 = 部[1]
          元 = 部[2]
          # add dst, src
          出 = 幕 + 足 + 先 + 点 + 元

         # CMP dst, src
         或 技 == 較:
          先 = 部[1]
          元 = 部[2]
          # cmp dst, src
          出 = 幕 + 比 + 先 + 点 + 元

         # JZ label -> je label
         或 技 == 零:
          先 = 部[1]
          # je label
          出 = 幕 + 跳 + 先

         # WRITE_MEM addr val
         或 技 == 書:
          先 = 部[1]
          元 = 部[2]
          # mov byte [mem_base + addr], val
          出 = 幕 + 転 + 基 + 先 + 閉 + 点 + 元

         # PUSH val -> mov qword [rsp+32], val
         或 技 == 押:
          元 = 部[1]
          # mov qword [rsp + 32], val
          出 = 幕 + 転 + 影 + 点 + 元
         
         # CALL_API name -> call name
         或 技 == 呼:
          先 = 部[1]
          # call name
          出 = 幕 + 喚 + 先

         # Output generated line
         も 寸(出) > 0:
          表(出)

         順 = 順 + 1

        # Output Footer
        表(尾)
        EOF

    # 20. Generate x64 ASM (既存のステップ)
    - name: 20. Generate x64 ASM
      run: |
        echo "--- Compiling x64 Compiler ---"
        python stage2_compiler.py compiler_x64.py1 > compiler_x64.py
        
        echo "--- Compiling WinIR to ASM ---"
        python compiler_x64.py fizzbuzz_win.ir > fizzbuzz.asm
        
        echo "--- ASM Content ---"
        cat fizzbuzz.asm

    # 21. Build & Run EXE
    - name: 21. Build & Run EXE
      run: |
        nasm -f win64 fizzbuzz.asm -o fizzbuzz.obj
        gcc fizzbuzz.obj -o fizzbuzz.exe
        ./fizzbuzz.exe
